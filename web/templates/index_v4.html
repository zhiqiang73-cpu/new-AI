<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Trading System v4.0</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Consolas', 'Monaco', monospace; 
            background: #0a0e11; 
            color: #e3e6e8; 
            font-size: 12px;
            line-height: 1.4;
        }
        
        .header {
            background: #1a1d23;
            border-bottom: 1px solid #2b3139;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-title {
            font-size: 18px;
            font-weight: 600;
            color: #f0b90b;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .current-time {
            font-size: 11px;
            color: #848e9c;
            font-weight: 400;
        }
        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }
        
        .header-stat {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .stat-label { color: #848e9c; }
        .stat-value.positive { color: #02c076; }
        .stat-value.negative { color: #f6465d; }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 350px;
            grid-template-rows: 320px 320px 1fr;
            gap: 8px;
            padding: 8px;
            height: calc(100vh - 60px);
        }
        
        /* Kçº¿å›¾ */
        .chart-card {
            background: #1a1d23;
            border: 1px solid #2b3139;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .chart-header {
            background: #1e2329;
            padding: 8px 12px;
            border-bottom: 1px solid #2b3139;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chart-title { font-weight: 600; font-size: 11px; color: #e3e6e8; }
        .chart-price { 
            font-size: 13px; 
            font-weight: 700; 
            font-family: 'Consolas', monospace;
        }
        .chart-price.up { color: #02c076; }
        .chart-price.down { color: #f6465d; }
        
        .chart-body { flex: 1; position: relative; }
        .chart-levels {
            position: absolute;
            bottom: 4px;
            left: 4px;
            font-size: 10px;
            background: rgba(26, 29, 35, 0.9);
            padding: 4px 6px;
            border-radius: 2px;
            line-height: 1.3;
        }
        
        /* å³ä¾§é¢æ¿ */
        .right-panel {
            grid-column: 3;
            grid-row: 1 / span 3;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
            min-height: 0;
        }
        
        .card {
            background: #1a1d23;
            border: 1px solid #2b3139;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .card-header {
            background: #1e2329;
            padding: 8px 12px;
            border-bottom: 1px solid #2b3139;
            font-weight: 600;
            font-size: 11px;
        }

        .card-header.clickable {
            cursor: pointer;
            user-select: none;
        }

        .collapse-indicator {
            float: right;
            color: #848e9c;
            font-size: 11px;
        }

        .collapsed .card-body {
            display: none;
        }

        /* æŠ˜å æ—¶å‹ç¼©å¡ç‰‡ä¸Šä¸‹ç©ºé—´ */
        .card.collapsed {
            min-height: 0 !important;
            height: auto;
            flex: 0 0 auto;
        }

        .card.collapsed .card-header {
            padding: 6px 10px;
        }

        .weight-delta {
            width: 70px;
            text-align: right;
            font-size: 11px;
        }

        .weight-delta.up {
            color: #02c076;
        }

        .weight-delta.down {
            color: #f6465d;
        }

        .weight-delta.flat {
            color: #848e9c;
        }
        
        .card-body {
            padding: 10px;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
        }
        
        /* AIå†³ç­–é€»è¾‘å¡ç‰‡ç‰¹æ®Šæ ·å¼ */
        #ai-logic {
            max-height: none;
            min-height: 200px;
        }
        
        /* æŒä»“ä¿¡æ¯ */
        .position-item {
            background: #252930;
            padding: 8px;
            border-radius: 3px;
            margin-bottom: 6px;
            font-size: 10px;
        }
        
        .position-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-weight: 600;
        }
        
        .position-side-long { color: #02c076; }
        .position-side-short { color: #f6465d; }
        
        .position-details {
            color: #848e9c;
            line-height: 1.5;
        }
        
        .position-pnl {
            margin-top: 4px;
            font-weight: 600;
        }
        
        .position-actions {
            margin-top: 6px;
            display: flex;
            gap: 4px;
        }
        
        /* AIå†³ç­–é€»è¾‘ */
        .logic-section {
            margin-bottom: 10px;
        }
        
        .logic-title {
            color: #f0b90b;
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 10px;
        }
        
        .logic-item {
            color: #848e9c;
            margin-left: 8px;
            margin-bottom: 2px;
            font-size: 10px;
            line-height: 1.4;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .logic-conclusion {
            color: #e3e6e8;
            font-weight: 600;
            margin-top: 6px;
            font-size: 10px;
        }
        
        /* ç¡®ä¿AIå†³ç­–é€»è¾‘å¡ç‰‡æ»šåŠ¨æ¡å¯è§ */
        #ai-logic::-webkit-scrollbar {
            width: 6px;
        }
        
        #ai-logic::-webkit-scrollbar-track {
            background: #1a1d23;
        }
        
        #ai-logic::-webkit-scrollbar-thumb {
            background: #2b3139;
            border-radius: 3px;
        }
        
        #ai-logic::-webkit-scrollbar-thumb:hover {
            background: #3a4149;
        }
        
        /* åº•éƒ¨åŒºåŸŸ */
        .bottom-panel {
            grid-column: 1 / span 2;
            grid-row: 3;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        /* äº¤æ˜“æ—¥å¿— */
        .log-item {
            padding: 4px 8px;
            border-bottom: 1px solid #252930;
            font-size: 10px;
            font-family: 'Consolas', monospace;
        }

        
        .log-time { color: #848e9c; margin-right: 8px; }
        .log-message { color: #e3e6e8; }
        
        .log-level-INFO { border-left: 2px solid #848e9c; }
        .log-level-SUCCESS { border-left: 2px solid #02c076; }
        .log-level-WARNING { border-left: 2px solid #f0b90b; }
        .log-level-ERROR { border-left: 2px solid #f6465d; }
        
        /* äº¤æ˜“å†å² */
        .trade-item {
            padding: 6px 8px;
            border-bottom: 1px solid #252930;
            font-size: 10px;
        }
        
        .trade-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        .trade-id { color: #848e9c; font-family: 'Consolas', monospace; }
        .trade-direction-LONG { color: #02c076; font-weight: 600; }
        .trade-direction-SHORT { color: #f6465d; font-weight: 600; }
        
        .trade-details { color: #848e9c; line-height: 1.4; }
        .trade-pnl { font-weight: 600; }
        .trade-pnl.positive { color: #02c076; }
        .trade-pnl.negative { color: #f6465d; }
        
        /* æŒ‰é’® */
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            transition: opacity 0.2s;
        }
        
        .btn:hover { opacity: 0.8; }
        
        .btn-primary { background: #f0b90b; color: #0b0e11; }
        .btn-success { background: #02c076; color: white; }
        .btn-danger { background: #f6465d; color: white; }
        .btn-secondary { background: #2b3139; color: #e3e6e8; }
        .btn-small { padding: 4px 8px; font-size: 9px; }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 4px;
        }
        
        .status-running { background: #02c076; }
        .status-stopped { background: #848e9c; }
        
        /* æ— æ•°æ®æç¤º */
        .no-data {
            color: #848e9c;
            text-align: center;
            padding: 20px;
            font-size: 10px;
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1d23; }
        ::-webkit-scrollbar-thumb { background: #2b3139; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #3c4043; }
    </style>
</head>
<body>
    <!-- å¤´éƒ¨ -->
    <div class="header">
        <div class="header-title">
            <span>BTC Trading System v4.0</span>
            <span class="current-time" id="current-time">Loading...</span>
        </div>
        
        <!-- Agentæ§åˆ¶æŒ‰é’® -->
        <div style="display: flex; gap: 10px; align-items: center;">
            <button class="btn btn-success" id="btn-start-agent" onclick="startAgent()" style="display: none;">
                Start Agent
            </button>
            <button class="btn btn-danger" id="btn-stop-agent" onclick="stopAgent()" style="display: none;">
                Stop Agent
            </button>
            <div class="header-stat">
                <span class="stat-label">Agent Status</span>
                <span class="stat-value" id="agent-status">
                    <span class="status-indicator status-stopped"></span>Stopped
                </span>
            </div>
        </div>
        
        <div class="header-stats">
            <div class="header-stat">
                <span class="stat-label">API Status</span>
                <span class="stat-value" id="api-status">
                    <span class="status-indicator status-stopped"></span>Disconnected
                </span>
            </div>
            <div class="header-stat">
                <span class="stat-label">Balance</span>
                <span class="stat-value" id="balance">$0.00</span>
            </div>
            <div class="header-stat">
                <span class="stat-label">Account Margin Used</span>
                <span class="stat-value" id="margin-used">$0.00</span>
            </div>
            <div class="header-stat">
                <span class="stat-label">Account Margin Free</span>
                <span class="stat-value" id="margin-available">$0.00</span>
            </div>
            <div class="header-stat">
                <span class="stat-label">Unrealized PnL</span>
                <span class="stat-value" id="unrealized-pnl">$0.00</span>
            </div>
        </div>
    </div>
    
    <!-- ä¸»å®¹å™¨ -->
    <div class="container">
        <!-- Kçº¿å›¾ - 1m -->
        <div class="chart-card">
            <div class="chart-header">
                <span class="chart-title">1m Chart (BTCUSDT)</span>
                <span class="chart-price up" id="price-1m">$0.00</span>
            </div>
            <div class="chart-body" id="chart-1m">
                <div class="chart-levels" id="levels-1m"></div>
            </div>
        </div>
        
        <!-- Kçº¿å›¾ - 15m -->
        <div class="chart-card">
            <div class="chart-header">
                <span class="chart-title">15m Chart (BTCUSDT)</span>
                <span class="chart-price up" id="price-15m">$0.00</span>
            </div>
            <div class="chart-body" id="chart-15m">
                <div class="chart-levels" id="levels-15m"></div>
            </div>
        </div>
        
        <!-- å³ä¾§é¢æ¿ -->
        <div class="right-panel">
            <!-- æŒä»“ä¿¡æ¯ -->
            <div class="card" style="min-height: 200px;">
                <div class="card-header">
                    æŒä»“ä¸è´¦æˆ·
                    <button class="btn btn-danger btn-small" onclick="closeAllPositions()" style="float: right; margin-top: -2px;">ä¸€é”®æ¸…ä»“</button>
                </div>
                <div class="card-body" id="positions-container">
                    <div class="no-data">æš‚æ— æŒä»“</div>
                </div>
            </div>

            <!-- å‚æ•°è®¾ç½® -->
            <div class="card collapsed" id="config-card" style="min-height: 140px;">
                <div class="card-header clickable" onclick="toggleConfigCard()">
                    å‚æ•°è®¾ç½®
                    <span class="collapse-indicator" id="config-toggle-text">ç‚¹å‡»å±•å¼€</span>
                </div>
                <div class="card-body" id="config-container">
                    <div style="font-size: 12px; color: #eaecef; margin-bottom: 6px;">
                        é è¿‘åå‘ä½é˜ˆå€¼ï¼ˆ%ï¼‰
                    </div>
                    <div style="display: flex; gap: 6px; align-items: center;">
                        <input
                            type="number"
                            id="near-sr-threshold"
                            min="0.01"
                            max="0.5"
                            step="0.01"
                            value="0.1"
                            style="width: 80px; background: #1e2329; color: #eaecef; border: 1px solid #2b3139; padding: 4px 6px; border-radius: 4px;"
                        />
                        <button class="btn btn-small" onclick="saveConfig()">ä¿å­˜</button>
                    </div>
                    <div style="font-size: 11px; color: #848e9c; margin-top: 6px;">
                        è·ç¦»â‰¤è¯¥å€¼æ—¶ï¼Œé˜»æ­¢åå‘å…¥åœº
                    </div>
                </div>
            </div>
            
            <!-- AIå†³ç­–é€»è¾‘ -->
            <div class="card" style="flex: 1; min-height: 300px; max-height: 500px;">
                <div class="card-header" style="position: sticky; top: 0; z-index: 10; background: #1e2329;">AI å†³ç­–é€»è¾‘</div>
                <div class="card-body" id="ai-logic" style="overflow-y: auto; overflow-x: hidden;">
                    <div class="no-data">ç­‰å¾…åˆ†æ...</div>
                </div>
            </div>

            <!-- å½“æ—¥æ€»ç»“ -->
            <div class="card collapsed" id="daily-report-card" style="min-height: 220px;">
                <div class="card-header clickable" onclick="toggleDailyReportCard()">
                    å½“æ—¥æ€»ç»“ï¼ˆæ‰‹ç»­è´¹/å‡€æ”¶ç›Š/æ•™è®­ï¼‰
                    <span class="collapse-indicator" id="daily-report-toggle-text">ç‚¹å‡»å±•å¼€</span>
                </div>
                <div class="card-body" id="daily-report-container">
                    <div class="no-data">æš‚æ— å½“æ—¥æ•°æ®</div>
                </div>
            </div>
            
            <!-- ç‰¹å¾æƒé‡ -->
            <div class="card collapsed" id="weights-card" style="min-height: 220px;">
                <div class="card-header clickable" onclick="toggleWeightsCard()">
                    ç‰¹å¾æƒé‡ï¼ˆæ”¯æ’‘/é˜»åŠ›ï¼‰
                    <span class="collapse-indicator" id="weights-toggle-text">ç‚¹å‡»å±•å¼€</span>
                </div>
                <div class="card-body" id="weights-container">
                    <div class="no-data">æš‚æ— æƒé‡</div>
                </div>
            </div>
            
            <!-- Kçº¿å½¢æ€ç»Ÿè®¡ -->
            <div class="card collapsed" id="patterns-card" style="min-height: 180px;">
                <div class="card-header clickable" onclick="togglePatternsCard()">
                    Kçº¿å½¢æ€ç»Ÿè®¡
                    <span class="collapse-indicator" id="patterns-toggle-text">ç‚¹å‡»å±•å¼€</span>
                </div>
                <div class="card-body" id="patterns-container">
                    <div class="no-data">æš‚æ— å½¢æ€æ•°æ®</div>
                </div>
            </div>
            
            <!-- AIå­¦ä¹ æ›²çº¿ -->
            <div class="card" style="min-height: 250px;">
                <div class="card-header">ğŸ§  AIè‡ªæˆ‘è¿›åŒ–ï¼ˆ6ç‰¹å¾å­¦ä¹ ï¼‰</div>
                <div class="card-body" id="learning-container">
                    <div class="no-data">å­¦ä¹ æ•°æ®åŠ è½½ä¸­...</div>
                </div>
            </div>
        </div>
        
        <!-- Kçº¿å›¾ - 8h -->
        <div class="chart-card">
            <div class="chart-header">
                <span class="chart-title">8h Chart (BTCUSDT)</span>
                <span class="chart-price up" id="price-8h">$0.00</span>
            </div>
            <div class="chart-body" id="chart-8h"></div>
        </div>
        
        <!-- Kçº¿å›¾ - 1w -->
        <div class="chart-card">
            <div class="chart-header">
                <span class="chart-title">1w Chart (BTCUSDT)</span>
                <span class="chart-price up" id="price-1w">$0.00</span>
            </div>
            <div class="chart-body" id="chart-1w"></div>
        </div>
        
        <!-- åº•éƒ¨é¢æ¿ -->
        <div class="bottom-panel">
            <!-- äº¤æ˜“æ—¥å¿— -->
            <div class="card">
                <div class="card-header">äº¤æ˜“æ—¥å¿—ï¼ˆå®æ—¶ï¼‰</div>
                <div class="card-body" id="logs-container" style="max-height: 300px; overflow-y: auto;">
                    <div class="no-data">æš‚æ— æ—¥å¿—</div>
                </div>
            </div>
            
            <!-- äº¤æ˜“å†å² -->
            <div class="card">
                <div class="card-header">äº¤æ˜“å†å²ï¼ˆæœ€è¿‘10ç¬”ï¼‰</div>
                <div class="card-body" id="trades-container" style="max-height: 300px; overflow-y: auto;">
                    <div class="no-data">æš‚æ— äº¤æ˜“</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // å…¨å±€å˜é‡
        const charts = {};
        const candlestickSeries = {};
        const volumeSeries = {};
        const supportLines = {};
        const resistanceLines = {};
        const tradeMarkers = {};
        
        // åˆå§‹åŒ–å›¾è¡¨
        function initCharts() {
            const intervals = ['1m', '15m', '8h', '1w'];
            
            intervals.forEach(interval => {
                const container = document.getElementById(`chart-${interval}`);
                
                // åˆ›å»ºå›¾è¡¨
                const chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    layout: {
                        background: { color: '#1a1d23' },
                        textColor: '#848e9c',
                    },
                    grid: {
                        vertLines: { color: '#252930' },
                        horzLines: { color: '#252930' },
                    },
                    timeScale: {
                        borderColor: '#2b3139',
                        timeVisible: true,
                        secondsVisible: false,
                        // è®© Lightweight Charts è‡ªåŠ¨æ ¹æ®ç¼©æ”¾çº§åˆ«è°ƒæ•´æ—¶é—´åˆ»åº¦
                    },
                    rightPriceScale: {
                        borderColor: '#2b3139',
                    },
                    localization: {
                        // ä½¿ç”¨ä¸­æ–‡æ—¥æœŸæ ¼å¼
                        locale: 'zh-CN',
                        // æ—¶é—´æ ¼å¼åŒ–
                        timeFormatter: (time) => {
                            const date = new Date(time * 1000);
                            const hours = date.getUTCHours().toString().padStart(2, '0');
                            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
                            return `${hours}:${minutes}`;
                        },
                    },
                });
                
                // æ·»åŠ Kçº¿ç³»åˆ—
                const candlestick = chart.addCandlestickSeries({
                    upColor: '#02c076',
                    downColor: '#f6465d',
                    borderUpColor: '#02c076',
                    borderDownColor: '#f6465d',
                    wickUpColor: '#02c076',
                    wickDownColor: '#f6465d',
                });
                
                // æ·»åŠ æˆäº¤é‡ç³»åˆ—ï¼ˆå ç”¨Kçº¿å›¾ä¸‹æ–¹çº¦10%ç©ºé—´ï¼Œæ¸…æ™°å¯è§ï¼‰
                const volume = chart.addHistogramSeries({
                    priceFormat: {
                        type: 'volume',
                    },
                    priceScaleId: 'volume',
                    scaleMargins: {
                        top: 0.90,  // é¡¶éƒ¨90%ï¼Œå ç”¨åº•éƒ¨10%ç©ºé—´
                        bottom: 0,
                    },
                    color: '#26a69a',
                });
                
                // è®¾ç½®æˆäº¤é‡ä»·æ ¼åˆ»åº¦ï¼ˆå ç”¨åº•éƒ¨10%ç©ºé—´ï¼‰
                chart.priceScale('volume').applyOptions({
                    scaleMargins: {
                        top: 0.90,  // é¡¶éƒ¨90%ï¼Œå ç”¨åº•éƒ¨10%ç©ºé—´
                        bottom: 0,
                    },
                    entireTextOnly: false,
                });
                
                charts[interval] = chart;
                candlestickSeries[interval] = candlestick;
                volumeSeries[interval] = volume;
                
                // åˆå§‹åŒ–æ”¯æ’‘é˜»åŠ›çº¿æ•°ç»„ï¼ˆåªfor 1må’Œ15mï¼‰
                if (interval === '1m' || interval === '15m') {
                    supportLines[interval] = [];
                    resistanceLines[interval] = [];
                }
            });
            
            // å“åº”å¼è°ƒæ•´
            window.addEventListener('resize', () => {
                intervals.forEach(interval => {
                    const container = document.getElementById(`chart-${interval}`);
                    charts[interval].resize(container.clientWidth, container.clientHeight);
                });
            });
        }
        
        // æ›´æ–°Kçº¿æ•°æ®
        async function updateKlines() {
            try {
                const response = await fetch('/api/klines_all/BTCUSDT');
                const data = await response.json();
                
                // æ—¶åŒºåç§»ï¼šä¸Šæµ·æ—¶é—´ UTC+8 = 8å°æ—¶ = 28800ç§’
                const SHANGHAI_OFFSET = 8 * 3600;
                
                Object.keys(data).forEach(interval => {
                    const klineData = data[interval];
                    
                    if (klineData && klineData.candles) {
                        // è½¬æ¢æ—¶é—´ä¸ºä¸Šæµ·æ—¶åŒºï¼ˆUTC+8ï¼‰
                        const candlesWithLocalTime = klineData.candles.map(candle => ({
                            time: candle.time + SHANGHAI_OFFSET,
                            open: candle.open,
                            high: candle.high,
                            low: candle.low,
                            close: candle.close
                        }));
                        
                        // æ›´æ–°Kçº¿
                        candlestickSeries[interval].setData(candlesWithLocalTime);
                        
                        // æ›´æ–°æˆäº¤é‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        if (klineData.volumes && volumeSeries[interval]) {
                            const volumesWithLocalTime = klineData.volumes.map((vol, idx) => {
                                const candle = candlesWithLocalTime[idx];
                                const color = candle && candle.close >= candle.open ? '#26a69a' : '#ef5350';
                                return {
                                    time: vol.time + SHANGHAI_OFFSET,
                                    value: vol.value,
                                    color: vol.color || color,
                                };
                            });
                            volumeSeries[interval].setData(volumesWithLocalTime);
                        }
                        
                        // æ›´æ–°ä»·æ ¼æ˜¾ç¤º
                        const lastCandle = klineData.candles[klineData.candles.length - 1];
                        const priceEl = document.getElementById(`price-${interval}`);
                        if (priceEl && lastCandle) {
                            const price = lastCandle.close;
                            priceEl.textContent = `$${price.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                            priceEl.className = lastCandle.close >= lastCandle.open ? 'chart-price up' : 'chart-price down';
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to update klines:', error);
            }
        }
        
        // æ›´æ–°æ”¯æ’‘é˜»åŠ›ä½
        async function updateSupportResistance() {
            try {
                const response = await fetch('/api/agent/levels');
                const data = await response.json();
                
                // åªä¸º1må’Œ15mæ›´æ–°æ”¯æ’‘é˜»åŠ›ä½æ˜¾ç¤ºå’Œç»˜åˆ¶çº¿æ¡
                ['1m', '15m'].forEach(interval => {
                    // æ›´æ–°æ–‡å­—æ˜¾ç¤º
                    const levelsEl = document.getElementById(`levels-${interval}`);
                    if (levelsEl) {
                        let html = '';
                        if (data.best_support) {
                            html += `<div style="color: #02c076;">S: ${data.best_support.price.toFixed(0)} (${data.best_support.score.toFixed(0)}pts)</div>`;
                        }
                        if (data.best_resistance) {
                            html += `<div style="color: #f6465d;">R: ${data.best_resistance.price.toFixed(0)} (${data.best_resistance.score.toFixed(0)}pts)</div>`;
                        }
                        levelsEl.innerHTML = html;
                    }
                    
                    // åœ¨å›¾è¡¨ä¸Šç»˜åˆ¶çº¿æ¡
                    const series = candlestickSeries[interval];
                    if (series) {
                        // ç§»é™¤æ—§çš„çº¿æ¡
                        if (supportLines[interval]) {
                            supportLines[interval].forEach(line => series.removePriceLine(line));
                        }
                        if (resistanceLines[interval]) {
                            resistanceLines[interval].forEach(line => series.removePriceLine(line));
                        }
                        
                        supportLines[interval] = [];
                        resistanceLines[interval] = [];
                        
                        // ç»˜åˆ¶æ”¯æ’‘ä½
                        if (data.best_support) {
                            const supportLine = series.createPriceLine({
                                price: data.best_support.price,
                                color: '#02c076',
                                lineWidth: 2,
                                lineStyle: 2, // Dashed
                                axisLabelVisible: true,
                                title: `S: ${data.best_support.price.toFixed(0)}`,
                            });
                            supportLines[interval].push(supportLine);
                        }
                        
                        // ç»˜åˆ¶é˜»åŠ›ä½
                        if (data.best_resistance) {
                            const resistanceLine = series.createPriceLine({
                                price: data.best_resistance.price,
                                color: '#f6465d',
                                lineWidth: 2,
                                lineStyle: 2, // Dashed
                                axisLabelVisible: true,
                                title: `R: ${data.best_resistance.price.toFixed(0)}`,
                            });
                            resistanceLines[interval].push(resistanceLine);
                        }
                    }
                });
                
                // æ›´æ–°ç‰¹å¾æƒé‡æ˜¾ç¤º
                renderFeatureWeights(data);
            } catch (error) {
                console.error('Failed to update S/R levels:', error);
            }
        }

        // ç‰¹å¾æƒé‡æŠ˜å æ§åˆ¶
        function toggleWeightsCard() {
            const card = document.getElementById('weights-card');
            const text = document.getElementById('weights-toggle-text');
            if (!card || !text) return;
            const collapsed = card.classList.toggle('collapsed');
            text.textContent = collapsed ? 'ç‚¹å‡»å±•å¼€' : 'ç‚¹å‡»æ”¶èµ·';
            try {
                localStorage.setItem('weightsCardCollapsed', collapsed ? '1' : '0');
            } catch (error) {
                // ignore
            }
        }

        function initWeightsCard() {
            const card = document.getElementById('weights-card');
            const text = document.getElementById('weights-toggle-text');
            if (!card || !text) return;
            let collapsed = true;
            try {
                collapsed = localStorage.getItem('weightsCardCollapsed') !== '0';
            } catch (error) {
                collapsed = true;
            }
            if (collapsed) {
                card.classList.add('collapsed');
                text.textContent = 'ç‚¹å‡»å±•å¼€';
            } else {
                card.classList.remove('collapsed');
                text.textContent = 'ç‚¹å‡»æ”¶èµ·';
            }
        }

        // å½¢æ€å¡ç‰‡æŠ˜å æ§åˆ¶
        function togglePatternsCard() {
            const card = document.getElementById('patterns-card');
            const text = document.getElementById('patterns-toggle-text');
            if (!card || !text) return;
            const collapsed = card.classList.toggle('collapsed');
            text.textContent = collapsed ? 'ç‚¹å‡»å±•å¼€' : 'ç‚¹å‡»æ”¶èµ·';
        }

        // å‚æ•°è®¾ç½®å¡ç‰‡æŠ˜å æ§åˆ¶
        function toggleConfigCard() {
            const card = document.getElementById('config-card');
            const text = document.getElementById('config-toggle-text');
            if (!card || !text) return;
            const collapsed = card.classList.toggle('collapsed');
            text.textContent = collapsed ? 'ç‚¹å‡»å±•å¼€' : 'ç‚¹å‡»æ”¶èµ·';
            try {
                localStorage.setItem('configCardCollapsed', collapsed ? '1' : '0');
            } catch (error) {
                // ignore
            }
        }

        function initConfigCard() {
            const card = document.getElementById('config-card');
            const text = document.getElementById('config-toggle-text');
            if (!card || !text) return;
            let collapsed = true;
            try {
                collapsed = localStorage.getItem('configCardCollapsed') !== '0';
            } catch (error) {
                collapsed = true;
            }
            if (collapsed) {
                card.classList.add('collapsed');
                text.textContent = 'ç‚¹å‡»å±•å¼€';
            } else {
                card.classList.remove('collapsed');
                text.textContent = 'ç‚¹å‡»æ”¶èµ·';
            }
        }

        async function loadConfig() {
            try {
                const res = await fetch('/api/config');
                const data = await res.json();
                const input = document.getElementById('near-sr-threshold');
                if (input && data && data.near_sr_threshold_pct != null) {
                    input.value = Number(data.near_sr_threshold_pct).toFixed(2);
                }
            } catch (error) {
                console.error('Failed to load config:', error);
            }
        }

        async function saveConfig() {
            const input = document.getElementById('near-sr-threshold');
            if (!input) return;
            const val = Number(input.value);
            if (!val || val < 0.01 || val > 0.5) {
                alert('é˜ˆå€¼èŒƒå›´åº”åœ¨ 0.01% - 0.50% ä¹‹é—´');
                return;
            }
            try {
                const res = await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ near_sr_threshold_pct: val })
                });
                const data = await res.json();
                if (data && data.near_sr_threshold_pct != null) {
                    input.value = Number(data.near_sr_threshold_pct).toFixed(2);
                }
            } catch (error) {
                console.error('Failed to save config:', error);
            }
        }

        function initPatternsCard() {
            const card = document.getElementById('patterns-card');
            const text = document.getElementById('patterns-toggle-text');
            if (!card || !text) return;
            card.classList.add('collapsed');
            text.textContent = 'ç‚¹å‡»å±•å¼€';
        }

        // å½“æ—¥æ€»ç»“å¡ç‰‡æŠ˜å æ§åˆ¶
        function toggleDailyReportCard() {
            const card = document.getElementById('daily-report-card');
            const text = document.getElementById('daily-report-toggle-text');
            if (!card || !text) return;
            const collapsed = card.classList.toggle('collapsed');
            text.textContent = collapsed ? 'ç‚¹å‡»å±•å¼€' : 'ç‚¹å‡»æ”¶èµ·';
            try {
                localStorage.setItem('dailyReportCardCollapsed', collapsed ? '1' : '0');
            } catch (error) {
                // ignore
            }
        }

        function initDailyReportCard() {
            const card = document.getElementById('daily-report-card');
            const text = document.getElementById('daily-report-toggle-text');
            if (!card || !text) return;
            let collapsed = true;
            try {
                collapsed = localStorage.getItem('dailyReportCardCollapsed') !== '0';
            } catch (error) {
                collapsed = true;
            }
            if (collapsed) {
                card.classList.add('collapsed');
                text.textContent = 'ç‚¹å‡»å±•å¼€';
            } else {
                card.classList.remove('collapsed');
                text.textContent = 'ç‚¹å‡»æ”¶èµ·';
            }
        }

        // æ¸²æŸ“ç‰¹å¾æƒé‡
        function renderFeatureWeights(data) {
            const container = document.getElementById('weights-container');
            if (!container) return;
            
            const weights = data && data.weights_display ? data.weights_display : [];
            if (!weights || weights.length === 0) {
                container.innerHTML = '<div class="no-data">æš‚æ— æƒé‡</div>';
                return;
            }
            
            const sorted = weights.slice().sort((a, b) => b.weight - a.weight);
            const prevMap = window.__lastWeights || {};
            let html = '';
            
            if (data.learning) {
                const total = data.learning.total_trades || 0;
                const effective = data.learning.effective_trades || 0;
                const effectRate = total > 0 ? (effective / total * 100).toFixed(1) : 0;
                const adjustments = data.learning.weight_adjustments || 0;
                const canAdjust = data.learning.can_adjust || false;
                html += `<div style="margin-bottom: 8px; color: #848e9c;">
                    äº¤æ˜“æ•°ï¼š${total} | æœ‰æ•ˆç‡ï¼š${effectRate}% | æƒé‡ä¼˜åŒ–ï¼š${adjustments}æ¬¡
                </div>`;
                if (!canAdjust) {
                    const minTrades = data.learning.min_trades_needed || 30;
                    html += `<div style="margin-bottom: 8px; color: #f0b90b;">
                        å­¦ä¹ å‡†å¤‡ä¸­ï¼š${total}/${minTrades}ï¼ˆ${((total/minTrades)*100).toFixed(0)}%ï¼‰
                    </div>`;
                } else {
                    html += `<div style="margin-bottom: 8px; color: #02c076;">
                        æŒç»­å­¦ä¹ ä¸­ âœ“
                    </div>`;
                }
            }
            
            sorted.forEach(item => {
                const pct = Number(item.weight || 0);
                const pctText = pct.toFixed(1);
                const prev = prevMap[item.name];
                const delta = prev == null ? null : pct - prev;
                const deltaText = delta == null ? '--' : `${delta >= 0 ? '+' : ''}${delta.toFixed(1)}%`;
                const deltaClass = delta == null ? 'flat' : (delta > 0 ? 'up' : (delta < 0 ? 'down' : 'flat'));
                html += `
                    <div style="display: flex; align-items: center; margin-bottom: 6px;">
                        <div style="flex: 1; color: #eaecef;">${item.name}</div>
                        <div style="width: 60px; text-align: right; color: #f0b90b;">${pctText}%</div>
                        <div class="weight-delta ${deltaClass}">${deltaText}</div>
                    </div>
                `;
            });

            const renderBreakdown = (title, breakdown) => {
                if (!breakdown || breakdown.length === 0) return '';
                let block = `<div style="margin-top: 10px; border-top: 1px solid #2b3139; padding-top: 8px;">`;
                block += `<div style="color:#848e9c; margin-bottom:6px;">${title}</div>`;
                breakdown.slice(0, 6).forEach(item => {
                    const valuePct = (Number(item.value || 0) * 100).toFixed(1);
                    const contribPct = Number(item.contribution_pct || 0).toFixed(1);
                    block += `
                        <div style="display:flex; align-items:center; margin-bottom:4px;">
                            <div style="flex:1; color:#eaecef;">${item.name}</div>
                            <div style="width:70px; text-align:right; color:#8a9;">${valuePct}%</div>
                            <div style="width:60px; text-align:right; color:#f0b90b;">${contribPct}%</div>
                        </div>
                    `;
                });
                block += '</div>';
                return block;
            };

            
            container.innerHTML = html;
            window.__lastWeights = sorted.reduce((acc, item) => {
                acc[item.name] = Number(item.weight || 0);
                return acc;
            }, {});
        }
        
        // æ›´æ–°äº¤æ˜“æ ‡è®°
        async function updateTradeMarkers() {
            try {
                const response = await fetch('/api/agent/trades');
                const data = await response.json();
                
                if (!data.trades || data.trades.length === 0) {
                    return;
                }
                
                // Kçº¿æ—¶é—´ = UTCæ—¶é—´æˆ³ + 8å°æ—¶ï¼Œä¸”æ˜¯æ¯åˆ†é’Ÿçš„å¼€ç›˜æ—¶é—´ï¼ˆæ•´åˆ†é’Ÿï¼‰
                // äº¤æ˜“æ—¶é—´ = æœ¬åœ°ISOå­—ç¬¦ä¸²ï¼ˆä¸Šæµ·æ—¶é—´ï¼‰ï¼Œéœ€è¦å‘ä¸‹å–æ•´åˆ°åˆ†é’Ÿ
                const SHANGHAI_OFFSET = 8 * 3600;
                const toChartTime = (ts) => {
                    if (!ts) return null;
                    const d = new Date(ts);
                    const utcSeconds = Math.floor(d.getTime() / 1000);
                    // å‘ä¸‹å–æ•´åˆ°åˆ†é’Ÿï¼ˆ60ç§’ï¼‰
                    const minuteAligned = Math.floor(utcSeconds / 60) * 60;
                    // åŠ 8å°æ—¶åç§»ï¼ˆä¸Kçº¿ä¸€è‡´ï¼‰
                    return minuteAligned + SHANGHAI_OFFSET;
                };
                
                // åªä¸º1må’Œ15mæ·»åŠ äº¤æ˜“æ ‡è®°
                ['1m', '15m'].forEach(interval => {
                    const series = candlestickSeries[interval];
                    if (!series) return;
                    
                    const markers = [];
                    
                    // ä¼˜å…ˆåŒ…å«å½“å‰æŒä»“çš„äº¤æ˜“æ ‡è®°
                    const activeTrades = data.trades.filter(t => !t.exit_time);
                    const closedTrades = data.trades.filter(t => t.exit_time);
                    const tradesForMarkers = [...activeTrades, ...closedTrades].slice(0, 80);

                    tradesForMarkers.forEach(trade => {
                        // å…¥åœºæ ‡è®°: L=Long(åšå¤š), S=Short(åšç©º) - å°ç®­å¤´
                        if (trade.entry_time) {
                            const entryTime = toChartTime(trade.entry_time);
                            if (!entryTime) return;
                            markers.push({
                                time: entryTime,
                                position: trade.direction === 'LONG' ? 'belowBar' : 'aboveBar',
                                color: trade.direction === 'LONG' ? '#02c076' : '#f6465d',
                                shape: trade.direction === 'LONG' ? 'arrowUp' : 'arrowDown',
                                text: trade.direction === 'LONG' ? 'L' : 'S',
                                size: 0,
                            });
                        }
                        
                        // å‡ºåœºæ ‡è®°: CL=Close Long(å¹³å¤š), CS=Close Short(å¹³ç©º) - å°ç®­å¤´
                        if (trade.exit_time && trade.exit_price) {
                            const exitTime = toChartTime(trade.exit_time);
                            if (!exitTime) return;
                            const isProfitable = trade.pnl >= 0;
                            markers.push({
                                time: exitTime,
                                position: trade.direction === 'LONG' ? 'aboveBar' : 'belowBar',
                                color: isProfitable ? '#f0b90b' : '#848e9c',
                                shape: trade.direction === 'LONG' ? 'arrowDown' : 'arrowUp',
                                text: trade.direction === 'LONG' ? 'CL' : 'CS',
                                size: 0,
                            });
                        }
                    });
                    
                    // æŒ‰æ—¶é—´å‡åºæ’åˆ—ï¼ˆLightweight Charts è¦æ±‚ï¼‰
                    markers.sort((a, b) => a.time - b.time);
                    
                    // è®¾ç½®æ ‡è®°
                    if (markers.length > 0) {
                        console.log(`Setting ${markers.length} markers for ${interval}, first:`, markers[0], 'last:', markers[markers.length-1]);
                    }
                    series.setMarkers(markers);
                });
                
            } catch (error) {
                console.error('Failed to update trade markers:', error);
            }
        }
        
        // æ›´æ–°æŒä»“ä¿¡æ¯
        async function updatePositions() {
            try {
                const [accountResp, positionsResp] = await Promise.all([
                    fetch('/api/account'),
                    fetch('/api/positions')
                ]);
                
                // æ›´æ–°è´¦æˆ·ä½™é¢
                const accountData = await accountResp.json();
                if (accountData.balances && accountData.balances.length > 0) {
                    const usdtBalance = accountData.balances.find(b => b.asset === 'USDT');
                    if (usdtBalance) {
                        document.getElementById('balance').textContent = `$${usdtBalance.total.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                    }
                }
                if (accountData.margin) {
                    const margin = accountData.margin || {};
                    const marginUsed = (margin.initialMargin != null)
                        ? Number(margin.initialMargin || 0)
                        : Number((margin.marginBalance || 0) - (margin.availableBalance || 0));
                    const marginFree = Number(margin.availableBalance || 0);
                    document.getElementById('margin-used').textContent = `$${marginUsed.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                    document.getElementById('margin-available').textContent = `$${marginFree.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                }
                
                // æ›´æ–°æŒä»“
                const positionsData = await positionsResp.json();
                const container = document.getElementById('positions-container');
                
                const exchangePositions = positionsData.positions || [];
                const agentEntries = positionsData.agent_entries || [];
                
                if (exchangePositions.length === 0 && agentEntries.length === 0) {
                    container.innerHTML = '<div class="no-data">æš‚æ— æŒä»“</div>';
                    document.getElementById('unrealized-pnl').textContent = '$0.00';
                    document.getElementById('unrealized-pnl').className = 'stat-value';
                    return;
                }
                
                // è®¡ç®—æ€»æœªå®ç°ç›ˆäº
                const totalPnl = exchangePositions.reduce((sum, p) => sum + p.pnl, 0);
                const pnlEl = document.getElementById('unrealized-pnl');
                pnlEl.textContent = `$${totalPnl.toLocaleString('en-US', {minimumFractionDigits: 2, signDisplay: 'always'})}`;
                pnlEl.className = totalPnl >= 0 ? 'stat-value positive' : 'stat-value negative';
                
                const formatTime = (ts) => {
                    if (!ts) return '--';
                    const dt = new Date(ts);
                    if (isNaN(dt.getTime())) return ts;
                    return dt.toLocaleString('zh-CN', { hour12: false });
                };
                const formatPriceWithPct = (value, entry) => {
                    if (!value || !entry) return '--';
                    const pct = ((value - entry) / entry) * 100;
                    const pctText = `${pct >= 0 ? '+' : ''}${pct.toFixed(2)}%`;
                    return `$${value.toFixed(2)} (${pctText})`;
                };
                let html = '';
                
                if (exchangePositions.length > 0) {
                    html += '<div style="margin-bottom: 10px; color: #848e9c;">äº¤æ˜“æ‰€æŒä»“</div>';
                    html += exchangePositions.map(pos => `
                        <div class="position-item">
                            <div class="position-header">
                                <span class="position-side-${pos.side.toLowerCase()}">${pos.side === 'LONG' ? 'å¤š' : 'ç©º'}</span>
                                <span>${pos.symbol}</span>
                                ${pos.tradeId ? `<span style="color:#6c757d;">${pos.tradeId.slice(0,8)}</span>` : ''}
                            </div>
                            <div class="position-details">
                                å¼€ä»“ä»·: $${pos.entryPrice.toFixed(2)} | å½“å‰ä»·: $${pos.markPrice.toFixed(2)}<br>
                                æ•°é‡: ${pos.amount.toFixed(4)} BTC | æ æ†: ${pos.leverage}x<br>
                                æ­¢æŸ: ${formatPriceWithPct(pos.stopLoss || 0, pos.entryPrice)} | æ­¢ç›ˆ: ${formatPriceWithPct(pos.takeProfit || 0, pos.entryPrice)}<br>
                                å¼ºå¹³: $${(pos.liquidationPrice || 0).toFixed(2)} | ä¿è¯é‡‘: $${Number(pos.marginUsed || 0).toFixed(2)}
                            </div>
                            <div class="position-pnl ${pos.pnl >= 0 ? 'positive' : 'negative'}">
                                ç›ˆäº: $${pos.pnl >= 0 ? '+' : ''}${pos.pnl.toFixed(2)} (${pos.pnlPercent >= 0 ? '+' : ''}${pos.pnlPercent.toFixed(2)}%)
                            </div>
                            <div class="position-actions">
                                <button class="btn btn-danger btn-small" onclick="closePosition('${pos.tradeId}', '${pos.symbol}', '${pos.side}', ${pos.amount}, ${pos.entryPrice}, ${pos.leverage}, '${pos.timestampOpen || ''}')">å¹³ä»“</button>
                            </div>
                        </div>
                    `).join('');
                }
                
                if (agentEntries.length > 0) {
                    const summary = positionsData.summary || {};
                    if (summary.exchange_qty != null && summary.agent_qty != null) {
                        const diffText = `${summary.qty_diff >= 0 ? '+' : ''}${Number(summary.qty_diff || 0).toFixed(4)}`;
                        const pctText = `${summary.pct_diff >= 0 ? '+' : ''}${Number(summary.pct_diff || 0).toFixed(2)}%`;
                        const warn = summary.has_mismatch ? 'color:#f0b90b;' : 'color:#848e9c;';
                        html += `
                            <div style="margin: 8px 0 6px; ${warn}">
                                äº¤æ˜“æ‰€æŒä»“æ€»é‡: ${Number(summary.exchange_qty || 0).toFixed(4)} BTC | 
                                AIå¼€ä»“æ€»é‡: ${Number(summary.agent_qty || 0).toFixed(4)} BTC | 
                                å·®å€¼: ${diffText} BTC (${pctText})
                            </div>
                        `;
                        if (summary.has_mismatch && summary.note) {
                            html += `<div style="margin: 0 0 6px; color:#f0b90b;">${summary.note}</div>`;
                        }
                        if (summary.exchange_margin_used != null || summary.agent_margin_used != null) {
                            html += `
                                <div style="margin: 0 0 6px; color:#848e9c;">
                                    äº¤æ˜“æ‰€æŒä»“ä¿è¯é‡‘åˆè®¡: $${Number(summary.exchange_margin_used || 0).toFixed(2)} |
                                    AIæŒä»“ä¿è¯é‡‘åˆè®¡: $${Number(summary.agent_margin_used || 0).toFixed(2)}
                                </div>
                            `;
                        }
                    }
                    html += '<div style="margin: 6px 0 6px; color: #848e9c;">AI å¼€ä»“æ˜ç»†ï¼ˆåˆ†æ‰¹ï¼‰</div>';
                    html += agentEntries.map(pos => `
                        <div class="position-item">
                            <div class="position-header">
                                <span class="position-side-${(pos.side || '').toLowerCase()}">${pos.side === 'LONG' ? 'å¤š' : 'ç©º'}</span>
                                <span>BTCUSDT</span>
                                ${pos.source === 'external' ? '<span style="color:#f0b90b;">å¤–éƒ¨</span>' : ''}
                                ${pos.tradeId ? `<span style="color:#6c757d;">${pos.tradeId.slice(0,8)}</span>` : ''}
                            </div>
                            <div class="position-details">
                                å¼€ä»“ä»·: $${pos.entryPrice.toFixed(2)} | å½“å‰ä»·: $${pos.markPrice.toFixed(2)}<br>
                                æ•°é‡: ${pos.amount.toFixed(4)} BTC | æ æ†: ${pos.leverage}x<br>
                                æ­¢æŸ: ${formatPriceWithPct(pos.stopLoss || 0, pos.entryPrice)} | æ­¢ç›ˆ: ${formatPriceWithPct(pos.takeProfit || 0, pos.entryPrice)}<br>
                                å¼ºå¹³: ${pos.liquidationPrice ? `$${pos.liquidationPrice.toFixed(2)}` : '--'} | ä¿è¯é‡‘: $${Number(pos.marginUsed || 0).toFixed(2)}<br>
                                å¼€ä»“æ—¶é—´: ${formatTime(pos.timestampOpen)}
                            </div>
                            <div class="position-pnl ${pos.pnl >= 0 ? 'positive' : 'negative'}">
                            ç›ˆäº: $${pos.pnl >= 0 ? '+' : ''}${pos.pnl.toFixed(2)} (${pos.pnlPercent >= 0 ? '+' : ''}${pos.pnlPercent.toFixed(2)}%)
                            </div>
                        </div>
                    `).join('');
                }
                
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to update positions:', error);
            }
        }
        
        // æ›´æ–°AIå†³ç­–é€»è¾‘
        async function updateAILogic() {
            try {
                const response = await fetch('/api/agent/status');
                const data = await response.json();
                
                const container = document.getElementById('ai-logic');
                
                if (!data.running) {
                    container.innerHTML = '<div class="no-data">Agentæœªè¿è¡Œ</div>';
                    return;
                }
                
                if (!data.ai_logic) {
                    container.innerHTML = '<div class="no-data">AIé€»è¾‘ä¸å¯ç”¨</div>';
                    return;
                }
                
                const exitReasonMap = {
                    STOP_LOSS: 'æ­¢æŸè§¦å‘',
                    TAKE_PROFIT: 'æ­¢ç›ˆè§¦å‘',
                    MAX_LOSS: 'æœ€å¤§äºæŸè§¦å‘',
                    TIME_COST: 'æ—¶é—´æˆæœ¬',
                    OPPORTUNITY_SWITCH: 'æœºä¼šåˆ‡æ¢',
                    PROFIT_LOCK: 'åˆ©æ¶¦é”å®š',
                };

                let html = '';
                const ai = data.ai_logic || {};
                const because = Array.isArray(ai.because) ? ai.because : [];
                const findPrefix = (prefix) => because.find((item) => item && item.startsWith(prefix)) || '';
                const bigTrend = findPrefix('å¤§è¶‹åŠ¿') || 'å¤§è¶‹åŠ¿: -';
                const smallTrend = findPrefix('å°è¶‹åŠ¿') || 'å°è¶‹åŠ¿: -';
                const rsi = findPrefix('RSI') || 'RSI: -';
                const macd = findPrefix('MACD') || 'MACD: -';
                const support = findPrefix('æ”¯æ’‘ä½') || 'æ”¯æ’‘ä½: -';
                const resistance = findPrefix('é˜»åŠ›ä½') || 'é˜»åŠ›ä½: -';

                const addSection = (title, lines) => {
                    const items = lines.filter(Boolean);
                    if (!items.length) return;
                    html += '<div class="logic-section" style="margin-top: 6px; border-top: 1px solid #2b3139; padding-top: 6px;">';
                    html += `<div class="logic-title">${title}</div>`;
                    items.slice(0, 3).forEach(line => {
                        html += `<div class="logic-item">${line}</div>`;
                    });
                    html += '</div>';
                };

                const decisionSummary = ai.decision_summary || ai.conclusion || 'è§‚æœ›';
                const decisionReasons = Array.isArray(ai.decision_reasons) ? ai.decision_reasons : [];
                const decisionBlockers = Array.isArray(ai.decision_blockers) ? ai.decision_blockers : [];
                addSection('å†³ç­–æ¦‚è¦', [
                    `å½“å‰å†³ç­–: ${decisionSummary}`,
                    decisionReasons.length ? `å…³é”®ä¾æ®: ${decisionReasons.join(' | ')}` : 'å…³é”®ä¾æ®: -',
                    decisionBlockers.length ? `é˜»æ‹¦å› ç´ : ${decisionBlockers.join(' | ')}` : 'é˜»æ‹¦å› ç´ : -',
                ]);

                let regimeLine = '';
                if (ai.regime) {
                    const rg = ai.regime;
                    const regimeLabels = {
                        'TRENDING': 'è¶‹åŠ¿è¡Œæƒ…',
                        'TRENDING_VOLATILE': 'æ³¢åŠ¨è¶‹åŠ¿',
                        'RANGING': 'éœ‡è¡è¡Œæƒ…',
                        'VOLATILE': 'é«˜æ³¢åŠ¨',
                        'NORMAL': 'å¸¸è§„å¸‚åœº',
                        'UNKNOWN': 'æœªçŸ¥',
                    };
                    regimeLine = `å¸‚åœºç»“æ„: ${regimeLabels[rg.regime] || rg.regime} ${Number(rg.confidence || 0) * 100 >> 0}%`;
                }

                let breakoutLine = '';
                if (ai.breakout) {
                    const br = ai.breakout;
                    const breakLabel = br.type === 'RESISTANCE_BREAK' ? 'é˜»åŠ›çªç ´(çœ‹å¤š)' : 'æ”¯æ’‘çªç ´(çœ‹ç©º)';
                    breakoutLine = `çªç ´: ${breakLabel} ${br.confirmed ? 'å·²ç¡®è®¤' : 'å¾…ç¡®è®¤'} ${Number(br.strength || 0) * 100 >> 0}%`;
                }

                addSection('å¸‚åœºä¸ç»“æ„', [
                    `è¶‹åŠ¿: ${bigTrend} | ${smallTrend}`,
                    `æŒ‡æ ‡: ${rsi} | ${macd}`,
                    `S/R: ${support} | ${resistance}${regimeLine ? ' | ' + regimeLine : ''}`,
                ]);

                const entry = ai.entry || {};
                const longScore = Number(entry.long_score || 0);
                const shortScore = Number(entry.short_score || 0);
                const thresholdScore = Number(entry.threshold || 0);
                let patternHint = '';
                if (entry.pattern_boost) {
                    const longBoost = Number(entry.pattern_boost.long || 0);
                    const shortBoost = Number(entry.pattern_boost.short || 0);
                    if (longBoost > 0 || shortBoost > 0) {
                        patternHint = ` | å½¢æ€åŠ åˆ†: å¤š+${longBoost} ç©º+${shortBoost}`;
                    }
                }
                const scoreLine = `è¯„åˆ†: å¤š${longScore.toFixed(0)} ç©º${shortScore.toFixed(0)} é˜ˆå€¼${thresholdScore.toFixed(0)}${patternHint}`;
                const entryDecision = Array.isArray(ai.therefore) && ai.therefore.length ? `è¯„åˆ†ç»“è®º: ${ai.therefore.join(' | ')}` : '';

                let lastEntryLine = '';
                if (entry.last_entry) {
                    const reason = entry.last_entry.reason || '-';
                    const dirLabel = entry.last_entry.direction || '-';
                    lastEntryLine = `æœ€è¿‘å…¥åœº: ${dirLabel} åˆ†æ•°${Number(entry.last_entry.strength || 0).toFixed(0)} | åŸå› : ${reason}`;
                } else {
                    lastEntryLine = 'æœ€è¿‘å…¥åœº: -';
                }

                addSection('å…¥åœºè¯„åˆ†', [scoreLine, entryDecision, breakoutLine]);

                let posLine = '';
                if (Array.isArray(ai.positions) && ai.positions.length > 0) {
                    const p = ai.positions[0];
                    const hold = p.hold_minutes == null ? '-' : `${p.hold_minutes.toFixed(1)}m`;
                    const pnlVal = Number(p.pnl_percent || 0);
                    const reason = exitReasonMap[p.exit_hint] || (p.exit_hint || 'æŒä»“ä¸­');
                    const pnlText = `${pnlVal >= 0 ? '+' : ''}${pnlVal.toFixed(2)}%`;
                    posLine = `æŒä»“: ${ai.positions.length}ç¬” | é¦–ç¬”${p.direction} æŒä»“${hold} PnL ${pnlText} | ${reason}`;
                    if (ai.positions.length > 1) {
                        posLine += ` | å…¶ä½™${ai.positions.length - 1}ç¬”ç•¥`;
                    }
                } else {
                    posLine = 'æŒä»“: æ— ';
                }
                addSection('æŒä»“ä¸æ‰§è¡Œ', [lastEntryLine, posLine]);

                let nsLine = '';
                if (ai.north_star && Object.keys(ai.north_star).length > 0) {
                    const ns = ai.north_star;
                    nsLine = `åŒ—ææ˜Ÿ: èƒœç‡${Number(ns.win_rate || 0).toFixed(2)}% ç›ˆäºæ¯”${Number(ns.profit_factor || 0).toFixed(2)} å¤æ™®${Number(ns.sharpe_ratio || 0).toFixed(3)} æ¨¡å¼${ns.mode || '-'}`;
                }
                let exitLine = '';
                if (ai.exit_learner) {
                    const el = ai.exit_learner;
                    exitLine = `ç¦»åœº: å¿«æ­¢ç›ˆ${Number(el.quick_profit_pct || 0.5).toFixed(2)}% æ ‡å‡†${Number(el.normal_profit_pct || 1.0).toFixed(2)}% æœ€å¤§æŒä»“${Number(el.max_hold_minutes || 60).toFixed(0)}åˆ†`;
                }
                if (ai.strategy_params) {
                    const sp = ai.strategy_params;
                    const riskLine = `é£æ§: æœºä¼šé˜ˆå€¼+${Number(sp.opportunity_delta || 0).toFixed(0)} æ—¶é—´æˆæœ¬${Number(sp.max_hold_minutes || 0).toFixed(0)}åˆ†/${Number(sp.min_profit_pct || 0).toFixed(2)}%`;
                    exitLine = exitLine ? `${exitLine} | ${riskLine}` : riskLine;
                }
                if (data.learning) {
                    const learnLine = `å­¦ä¹ : ${data.learning.total_trades}/${data.learning.min_trades_needed} ä¼˜åŒ–${data.learning.weight_adjustments}æ¬¡`;
                    exitLine = exitLine ? `${exitLine} | ${learnLine}` : learnLine;
                }
                addSection('å­¦ä¹ ä¸é£æ§', [nsLine, exitLine]);

                container.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to update AI logic:', error);
            }
        }
        
        // æ›´æ–°äº¤æ˜“æ—¥å¿—
        async function updateLogs() {
            try {
                const response = await fetch('/api/agent/logs');
                const data = await response.json();
                
                const container = document.getElementById('logs-container');
                
                if (!data.logs || data.logs.length === 0) {
                    container.innerHTML = '<div class="no-data">æš‚æ— æ—¥å¿—</div>';
                    return;
                }
                
                // æœ€æ–°æ—¥å¿—æ˜¾ç¤ºåœ¨æœ€ä¸Šé¢
                const logs = [...data.logs].reverse();
                
                container.innerHTML = logs.slice(0, 20).map(log => `
                    <div class="log-item log-level-${log.level}">
                        <span class="log-time">${log.time}</span>
                        <span class="log-message">${log.message}</span>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Failed to update logs:', error);
            }
        }
        
        // æ›´æ–°äº¤æ˜“å†å²
        async function updateTrades() {
            try {
                const response = await fetch('/api/agent/trades');
                const data = await response.json();
                
                const container = document.getElementById('trades-container');
                
                if (!data.trades || data.trades.length === 0) {
                    container.innerHTML = '<div class="no-data">æš‚æ— äº¤æ˜“</div>';
                    return;
                }
                
                container.innerHTML = data.trades.slice(0, 10).map(trade => {
                    const pnlClass = trade.pnl >= 0 ? 'positive' : 'negative';
                    const isActive = trade.is_active ? 'ï¼ˆæŒä»“ä¸­ï¼‰' : '';
                    const pnlVal = Number(trade.pnl || 0);
                    const pnlPctVal = Number(trade.pnl_percent || 0);
                    const rawPnlVal = Number(trade.raw_pnl || 0);
                    const commissionVal = Number(trade.commission || 0);
                    
                    // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º (å¹´æœˆæ—¥ æ—¶:åˆ†)
                    let entryTimeStr = '';
                    let exitTimeStr = '';
                    
                    if (trade.entry_time) {
                        try {
                            // ISOæ ¼å¼: 2024-01-15T14:30:00 æˆ– 2024-01-15T14:30:00.000000
                            const entryDate = new Date(trade.entry_time);
                            if (!isNaN(entryDate.getTime())) {
                                // è½¬æ¢ä¸ºä¸Šæµ·æ—¶é—´ (UTC+8)
                                const shanghaiOffset = 8 * 60 * 60 * 1000;
                                const shanghaiTime = new Date(entryDate.getTime() + shanghaiOffset);
                                const year = shanghaiTime.getUTCFullYear();
                                const month = String(shanghaiTime.getUTCMonth() + 1).padStart(2, '0');
                                const day = String(shanghaiTime.getUTCDate()).padStart(2, '0');
                                const hour = String(shanghaiTime.getUTCHours()).padStart(2, '0');
                                const minute = String(shanghaiTime.getUTCMinutes()).padStart(2, '0');
                                entryTimeStr = `${year}-${month}-${day} ${hour}:${minute}`;
                            } else {
                                // å¦‚æœDateè§£æå¤±è´¥ï¼Œå°è¯•ç›´æ¥æ ¼å¼åŒ–å­—ç¬¦ä¸²
                                entryTimeStr = trade.entry_time.substring(0, 16).replace('T', ' ');
                            }
                        } catch (e) {
                            // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥æˆªå–å¹¶æ ¼å¼åŒ–
                            entryTimeStr = trade.entry_time.substring(0, 16).replace('T', ' ');
                        }
                    }
                    
                    if (trade.exit_time) {
                        try {
                            const exitDate = new Date(trade.exit_time);
                            if (!isNaN(exitDate.getTime())) {
                                const shanghaiOffset = 8 * 60 * 60 * 1000;
                                const shanghaiTime = new Date(exitDate.getTime() + shanghaiOffset);
                                const year = shanghaiTime.getUTCFullYear();
                                const month = String(shanghaiTime.getUTCMonth() + 1).padStart(2, '0');
                                const day = String(shanghaiTime.getUTCDate()).padStart(2, '0');
                                const hour = String(shanghaiTime.getUTCHours()).padStart(2, '0');
                                const minute = String(shanghaiTime.getUTCMinutes()).padStart(2, '0');
                                exitTimeStr = `${year}-${month}-${day} ${hour}:${minute}`;
                            } else {
                                exitTimeStr = trade.exit_time.substring(0, 16).replace('T', ' ');
                            }
                        } catch (e) {
                            exitTimeStr = trade.exit_time.substring(0, 16).replace('T', ' ');
                        }
                    }
                    
                    // ç”Ÿæˆå½¢æ€æ ‡ç­¾
                    let patternTags = '';
                    if (trade.patterns && Array.isArray(trade.patterns) && trade.patterns.length > 0) {
                        const patternNames = trade.patterns.map(p => p.name_cn || p.name).join(', ');
                        patternTags = `<br><span style="color: #f0b90b;">å½¢æ€: ${patternNames}</span>`;
                    }
                    
                    return `
                        <div class="trade-item">
                            <div class="trade-header">
                                <span class="trade-id">${trade.trade_id.substring(0, 8)}${isActive}</span>
                                <span class="trade-direction-${trade.direction}">${trade.direction === 'LONG' ? 'å¤š' : 'ç©º'}</span>
                            </div>
                            <div class="trade-details">
                                ${entryTimeStr ? `<span style="color: #848e9c;">å¼€ä»“æ—¶é—´: ${entryTimeStr}</span><br>` : ''}
                                å¼€ä»“: $${trade.entry_price.toFixed(2)} | ${trade.exit_price ? `å¹³ä»“: $${trade.exit_price.toFixed(2)}` : 'æŒä»“ä¸­'}<br>
                                ${exitTimeStr ? `<span style="color: #848e9c;">å¹³ä»“æ—¶é—´: ${exitTimeStr}</span><br>` : ''}
                                æ•°é‡: ${trade.quantity.toFixed(4)} BTC @ ${trade.leverage}x<br>
                                <span class="trade-pnl ${pnlClass}">å‡€æ”¶ç›Š: $${pnlVal >= 0 ? '+' : ''}${pnlVal.toFixed(2)} (${pnlPctVal >= 0 ? '+' : ''}${pnlPctVal.toFixed(2)}%)</span>
                                <br>
                                <span style="color:#848e9c;">æ¯›æ”¶ç›Š: $${rawPnlVal >= 0 ? '+' : ''}${rawPnlVal.toFixed(2)} | æ‰‹ç»­è´¹: $${commissionVal.toFixed(4)}</span>
                                ${trade.exit_reason ? ` | åŸå› : ${trade.exit_reason}` : ''}
                                ${patternTags}
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Failed to update trades:', error);
            }
        }
        
        // å¯åŠ¨Agent
        async function startAgent() {
            try {
                const response = await fetch('/api/agent/start', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    updateAgentStatus();
                } else {
                    alert('Failed to start: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
        
        // åœæ­¢Agent
        async function stopAgent() {
            if (!confirm('Are you sure you want to stop the Agent?')) {
                return;
            }
            
            try {
                const response = await fetch('/api/agent/stop', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    updateAgentStatus();
                } else {
                    alert('Failed to stop: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
        
        // æ›´æ–°AgentçŠ¶æ€
        async function updateAgentStatus() {
            try {
                const response = await fetch('/api/agent/status');
                const data = await response.json();
                
                const statusEl = document.getElementById('agent-status');
                const startBtn = document.getElementById('btn-start-agent');
                const stopBtn = document.getElementById('btn-stop-agent');
                
                if (data.running) {
                    statusEl.innerHTML = '<span class="status-indicator status-running"></span>Running';
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'block';
                } else {
                    statusEl.innerHTML = '<span class="status-indicator status-stopped"></span>Stopped';
                    startBtn.style.display = 'block';
                    stopBtn.style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to update agent status:', error);
            }
        }
        
        // ä¸€é”®æ¸…ä»“
        async function closeAllPositions() {
            if (!confirm('Are you sure you want to close ALL positions?')) {
                return;
            }
            
            try {
                const response = await fetch('/api/close_all', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    alert(`Closed ${data.closed} position(s)`);
                    updatePositions();
                } else {
                    alert('Failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
        
        // å¹³ä»“å•ä¸ªæŒä»“
        async function closePosition(tradeId, symbol, side, quantity, entryPrice, leverage, timestampOpen) {
            try {
                const response = await fetch('/api/close', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tradeId,
                        symbol,
                        side,
                        quantity,
                        entryPrice,
                        leverage,
                        timestamp_open: timestampOpen || null
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updatePositions();
                    updateTrades();
                } else {
                    alert('Failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
        
        // æ›´æ–°å½“å‰æ—¶é—´ï¼ˆä¸Šæµ·æ—¶é—´ï¼‰
        function updateCurrentTime() {
            const now = new Date();
            const timeStr = now.toLocaleString('zh-CN', { 
                timeZone: 'Asia/Shanghai',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            document.getElementById('current-time').textContent = `Shanghai Time: ${timeStr}`;
        }
        
        // æ£€æŸ¥APIçŠ¶æ€
        async function checkAPIStatus() {
            try {
                const response = await fetch('/api/account');
                const statusEl = document.getElementById('api-status');
                
                if (response.ok) {
                    statusEl.innerHTML = '<span class="status-indicator status-running"></span>Connected';
                } else {
                    statusEl.innerHTML = '<span class="status-indicator status-stopped"></span>Disconnected';
                }
            } catch (error) {
                const statusEl = document.getElementById('api-status');
                statusEl.innerHTML = '<span class="status-indicator status-stopped"></span>Disconnected';
            }
        }
        
        // æ›´æ–°Kçº¿å½¢æ€ç»Ÿè®¡
        async function updatePatterns() {
            try {
                const response = await fetch('/api/agent/patterns');
                const data = await response.json();
                const container = document.getElementById('patterns-container');
                if (!container) return;
                
                const totalCount = data.total?.count || 0;
                if (totalCount === 0) {
                    container.innerHTML = '<div class="no-data">æš‚æ— å½¢æ€è§¦å‘</div>';
                    return;
                }
                
                let html = `<div style="margin-bottom: 8px; color: #848e9c;">æ€»è§¦å‘: ${totalCount}æ¬¡ | æ€»ç›ˆäº: $${(data.total?.pnl || 0).toFixed(2)}</div>`;
                
                const renderPatternList = (title, patterns) => {
                    if (!patterns || patterns.length === 0) return '';
                    let block = `<div style="margin-top: 8px; border-top: 1px solid #2b3139; padding-top: 6px;"><div style="color:#848e9c; margin-bottom:4px;">${title}</div>`;
                    patterns.forEach(p => {
                        const pnlColor = p.pnl >= 0 ? '#02c076' : '#f6465d';
                        block += `<div style="margin-bottom:3px; font-size:10px;">
                            <span style="color:#eaecef;">${p.name_cn}</span>
                            <span style="color:#848e9c;"> x${p.count}</span>
                            <span style="color:${pnlColor};"> $${p.pnl.toFixed(2)}</span>
                            <span style="color:#f0b90b;"> èƒœç‡${p.win_rate.toFixed(0)}%</span>
                        </div>`;
                    });
                    block += '</div>';
                    return block;
                };
                
                html += renderPatternList('åšå¤šå½¢æ€', data.long);
                html += renderPatternList('åšç©ºå½¢æ€', data.short);
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to update patterns:', error);
            }
        }
        
        // æ›´æ–°AIå­¦ä¹ æ›²çº¿ï¼ˆæ ¸å¿ƒè¿›åŒ–å±•ç¤ºï¼‰
        async function updateLearning() {
            try {
                const response = await fetch('/api/agent/learning');
                const data = await response.json();
                const container = document.getElementById('learning-container');
                if (!container) return;
                
                const weights = data.weights || {};
                const weights_cn = data.weights_cn || {};
                const history = data.history || [];
                
                if (Object.keys(weights).length === 0) {
                    container.innerHTML = '<div class="no-data">å­¦ä¹ ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>';
                    return;
                }
                
                let html = '';
                
                // ç‰¹å¾æƒé‡æ’è¡Œï¼ˆæŒ‰ç»å¯¹å€¼æ’åºï¼‰
                const weightEntries = Object.entries(weights).map(([k, v]) => ({
                    key: k,
                    name: weights_cn[k] || k,
                    value: Number(v),
                    absValue: Math.abs(Number(v))
                }));
                weightEntries.sort((a, b) => b.absValue - a.absValue);
                
                html += '<div style="margin-bottom: 10px; border-bottom: 1px solid #2b3139; padding-bottom: 8px;">';
                html += '<div style="color:#f0b90b; font-size:11px; margin-bottom:6px;">ğŸ“Š ç‰¹å¾é‡è¦æ€§æ’è¡Œ</div>';
                weightEntries.forEach((item, idx) => {
                    const pct = (item.value * 100).toFixed(1);
                    const barWidth = item.absValue * 100;
                    const color = item.value >= 0 ? '#02c076' : '#f6465d';
                    html += `
                        <div style="margin-bottom: 6px;">
                            <div style="display:flex; justify-content:space-between; font-size:10px;">
                                <span style="color:#eaecef;">${idx + 1}. ${item.name}</span>
                                <span style="color:${color};">${pct >= 0 ? '+' : ''}${pct}%</span>
                            </div>
                            <div style="width:100%; height:4px; background:#2b3139; border-radius:2px; overflow:hidden;">
                                <div style="width:${barWidth}%; height:100%; background:${color};"></div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                
                // å­¦ä¹ å†å²ï¼ˆæœ€è¿‘10ç¬”ï¼‰
                if (history.length > 0) {
                    html += '<div style="margin-top: 8px;">';
                    html += '<div style="color:#f0b90b; font-size:11px; margin-bottom:6px;">ğŸ“ˆ å­¦ä¹ è®°å½•ï¼ˆæœ€è¿‘10ç¬”ï¼‰</div>';
                    const recent = history.slice(-10).reverse();
                    let winCount = 0;
                    recent.forEach((h, idx) => {
                        const pnl = Number(h.pnl_percent || 0);
                        if (pnl > 0) winCount++;
                        const pnlColor = pnl >= 0 ? '#02c076' : '#f6465d';
                        const rewardColor = h.reward >= 0 ? '#02c076' : '#f6465d';
                        html += `<div style="font-size:9px; color:#848e9c; margin-bottom:2px;">
                            ${recent.length - idx}. PnL: <span style="color:${pnlColor};">${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}%</span> 
                            | å¥–åŠ±: <span style="color:${rewardColor};">${h.reward >= 0 ? '+' : ''}${h.reward.toFixed(3)}</span>
                        </div>`;
                    });
                    const recentWinRate = (winCount / recent.length * 100).toFixed(0);
                    html += `<div style="margin-top:6px; color:#f0b90b; font-size:10px;">è¿‘æœŸèƒœç‡: ${recentWinRate}%</div>`;
                    html += '</div>';
                }
                
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to update learning:', error);
            }
        }

        // å½“æ—¥æ€»ç»“ï¼ˆæ‰‹ç»­è´¹åå™¬ç‡ / å‡€æ”¶ç›Š / äºæŸæ•™è®­ï¼‰
        async function updateDailyReport() {
            try {
                const response = await fetch('/api/daily_report');
                const data = await response.json();
                const container = document.getElementById('daily-report-container');
                if (!container) return;

                if (!data || !data.has_data) {
                    container.innerHTML = '<div class="no-data">æš‚æ— å½“æ—¥æ•°æ®</div>';
                    return;
                }

                const s = data.summary || {};
                const netColor = (Number(s.net_pnl || 0) >= 0) ? '#02c076' : '#f6465d';
                const feeColor = (Number(s.total_commission || 0) > 0 && Number(s.net_pnl || 0) <= Number(s.total_commission || 0))
                    ? '#f0b90b' : '#848e9c';
                const feeRatio = Number(s.fee_ratio || 0) * 100;
                const netGtFee = s.net_gt_fee ? 'âœ…' : 'âš ï¸';

                let html = '';
                html += `<div style="margin-bottom:6px; color:#f0b90b;">ğŸ“… å½“æ—¥: ${s.date || '-'} | æˆäº¤ ${s.total_trades || 0} ç¬” | èƒœç‡ ${Number(s.win_rate || 0).toFixed(1)}%</div>`;
                html += `<div style="font-size:12px; color:${netColor};">å‡€æ”¶ç›Š: $${Number(s.net_pnl || 0).toFixed(2)} (${netGtFee} å‡€æ”¶ç›Š > æ‰‹ç»­è´¹)</div>`;
                html += `<div style="font-size:12px; color:#848e9c;">æ¯›æ”¶ç›Š: $${Number(s.gross_pnl || 0).toFixed(2)} | æ‰‹ç»­è´¹: $${Number(s.total_commission || 0).toFixed(4)} <span style="color:${feeColor};">åå™¬ç‡ ${feeRatio.toFixed(1)}%</span></div>`;
                html += `<div style="font-size:12px; color:#848e9c;">å•ç¬”å‡å€¼: $${Number(s.avg_pnl || 0).toFixed(2)} | å¹³å‡ç›ˆåˆ©: $${Number(s.avg_win || 0).toFixed(2)} | å¹³å‡äºæŸ: $${Number(s.avg_loss || 0).toFixed(2)}</div>`;

                const lessons = data.loss_lessons || [];
                if (lessons.length) {
                    html += '<div style="margin-top:8px; color:#f0b90b; font-size:11px;">ğŸ§¾ äºæŸäº¤æ˜“æ•™è®­æ¸…å•</div>';
                    lessons.forEach(section => {
                        const titleMap = {
                            'exit_reason': 'ä¸»è¦äºæŸå‡ºåœºåŸå› ',
                            'market_state': 'æ˜“äºå¸‚åœºçŠ¶æ€',
                            'pattern': 'é«˜é£é™©å½¢æ€',
                        };
                        const title = titleMap[section.type] || section.type;
                        html += `<div style="margin-top:6px; color:#848e9c; font-size:11px;">${title}ï¼š</div>`;
                        (section.items || []).forEach(item => {
                            html += `<div style="font-size:11px; color:#eaecef;">- ${item.name} | ${item.count}æ¬¡ | å¹³å‡äºæŸ $${Number(item.avg_pnl || 0).toFixed(2)}</div>`;
                        });
                    });
                }

                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update daily report:', error);
            }
        }
        
        // ä¸»æ›´æ–°å¾ªç¯
        function startUpdateLoop() {
            // åˆå§‹åŠ è½½
            updateCurrentTime();
            updateAgentStatus();
            updateKlines();
            updateSupportResistance();
            updateTradeMarkers();
            updatePositions();
            updateAILogic();
            updateLogs();
            updateTrades();
            updatePatterns();
            updateLearning();
            updateDailyReport();
            checkAPIStatus();
            initDailyReportCard();
            initConfigCard();
            loadConfig();
            
            // æ¯ç§’æ›´æ–°æ—¶é’Ÿ
            setInterval(updateCurrentTime, 1000);
            
            // 1ç§’åˆ·æ–°Kçº¿å’ŒæŒä»“ï¼ŒKçº¿æ›´æ–°åç«‹å³åˆ·æ–°æ ‡è®°ï¼ˆå› ä¸ºsetDataä¼šæ¸…é™¤markersï¼‰
            setInterval(async () => {
                await updateKlines();
                await updateTradeMarkers();
                updatePositions();
            }, 1000);
            
            // 2ç§’åˆ·æ–°æ”¯æ’‘é˜»åŠ›
            setInterval(updateSupportResistance, 2000);
            
            // 1ç§’åˆ·æ–°AIé€»è¾‘å’Œæ—¥å¿—
            setInterval(() => {
                updateAILogic();
                updateLogs();
            }, 1000);
            
            // 3ç§’åˆ·æ–°äº¤æ˜“å†å²ã€å½¢æ€ç»Ÿè®¡å’Œå­¦ä¹ æ›²çº¿
            setInterval(() => {
                updateTrades();
                updatePatterns();
                updateLearning();
                updateDailyReport();
            }, 3000);
            
            // 5ç§’æ£€æŸ¥APIçŠ¶æ€
            setInterval(checkAPIStatus, 5000);
            
            // 2ç§’åˆ·æ–°AgentçŠ¶æ€
            setInterval(updateAgentStatus, 2000);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            initCharts();
            initWeightsCard();
            initPatternsCard();
            startUpdateLoop();
        });
    </script>
</body>
</html>

